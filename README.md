# Python

    python -m pip install --upgrade pip

 ### Деление всегда возвращает float
    print(7 / 2)	# 3.5

### Вычисление последней цифры числа
    239 % 10	# 9

### Получить само число без последней цифры
    239 // 10		# 23

### Квадратный корень из числа
    9 ** 0.5		# 3

>Любые арифметические операции выше по приоритету операций сравнения и логических операторов.
Порядок приоритета: not | and | or

>Сравнение строк (1 < A < a). Цифровой символ условно меньше, чем любой алфавитный символ.
Алфавитный символ в верхнем регистре условно меньше, чем алфавитные символы в нижнем регистре.
Если первые символы одинаковые, в расчет берутся вторые символы при их наличии.

## Управляющие последовательности
* \\ - позволяет добавить внутрь строки слэш
* \' - позволяет добавить внутрь строки одинарную кавычку
* \" - позволяет добавить внутрь строки двойную кавычку
* \n - осуществляет переход на новую строку
* \t - добавляет табуляцию (4 отступа)

### Все, что не ноль и не пустота, это True.
    print(bool(2.3))    # True
    print(bool(0))      # False
    print(bool(""))     # False

***

## Дополнительный блок else
Для цикла while также можно определить дополнительный блок else, инструкции которого выполняются, когда условие равно False.

Цикл for также может иметь дополнительный блок else, который выполняется после завершения цикла.

***
## Диапазоны
>range(stop): возвращает все целые числа от 0 до stop (не включая)

>range(start, stop): возвращает все целые числа в промежутке от start (включая) до stop (не включая)

>range(start, stop, step): возвращает целые числа в промежутке от start (включая) до stop (не включая), которые увеличиваются на значение step

***
## Списки
Список необязательно должен содержать только однотипные объекты. Мы можем поместить в один и тот же список одновременно строки, числа, объекты других типов данных.

«Поверхностное копирование» (shallow copy)
При копировании списков следует учитывать, что списки представляют изменяемый (mutable) тип, поэтому если обе переменных будут указывать на один и тот же список, то изменение одной переменной, затронет и другую переменную.

    people1 = ["Tom", "Bob", "Alice"]
    people2 = people1
    people2.append("Sam")   # добавляем элемент во второй список
> people1 и people2 указывают на один и тот же список

Чтобы происходило копирование элементов, но при этом переменные указывали на разные списки, необходимо выполнить глубокое копирование (deep copy). Для этого можно использовать метод copy():

    people1 = ["Tom", "Bob", "Alice"]
    people2 = people1.copy()    # копируем элементы из people1 в people2
    people2.append("Sam")   # добавляем элемент ТОЛЬКО во второй список
> people1 и people2 указывают на разные списки

Функция sorted(list) не изменяет сортируемый список, а все отсортированные элементы она помещает в новый список, который возвращается в качестве результата.

Чтобы обратиться к элементу вложенного списка, необходимо использовать пару индексов: `people[0][1]` - обращение ко второму элементу первого вложенного списка.

***
